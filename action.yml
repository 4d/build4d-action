# action.yml
name: 'Build 4D'
author: 'Eric Marchand'
branding:
  icon: 'package'
  color: 'blue'
description: 'Build 4D code'
inputs:
  project:
    description: 'Project to build'
    required: false

  targets:
    description: "If not defined, only a check syntax is done. Possible values: \"x86_64_generic\", \"arm64_macOS_lib\" if macOS. (some shortcut all, current, available)"
    required: false
    default: ""
  type-inference:
    description: "String	\"all\": Type all variables,\n  \"locals\": Process and interprocess are typed,\n  \"none\": \"All variables are typed\""
    required: false
    default: "none"
  generate-symbols:
    description: "true to generate symbol information in the .symbols returned object"
    required: false
    default: "False"
  generate-typing-methods:   
    description: "\"reset\" or \"append\" to generate typing methods.\nIf value is \"append\", existing variable declarations won't be modified (compiler window behavior).\nIf value is \"reset\" existing variable declarations are removed beforehand."
    required: false
    default: ""
  ignore-warnings:   
    description: "Never display compilation warnings."
    required: false
    default: "False"
  fail-on-warning:   
    description: "Failed on warnings."
    required: false
    default: "False"
  actions:   
    description: "One or more among \"build\",\"pack\",\"sign\",\"archive\""
    required: false
    default: ""
  output-directory:   
    description: "Directory to output build. Default is \"build\""
    required: false
    default: ""
  sign-certificate:   
    description: "Name of the certificate to use. Mandatory to sign on macOS."
    required: false
    default: ""
  sign-files:   
    description: "List of file paths to sign too relative to base folder"
    required: false
    default: ""
  entitlements-file:   
    description: "Path of entitlement files to sign (if not defined use default one)"
    required: false
    default: ""
  sign-certificate-base64:
    description: "Base64 encoded certificate (P12/PFX format)"
    required: false
    default: ""
  sign-certificate-password:
    description: "Password for the certificate"
    required: false
    default: ""
  sign-certificate-path:
    description: "Path to certificate file (P12/PFX)"
    required: false
    default: ""
  keychain-password:
    description: "Password for keychain (macOS only)"
    required: false
    default: ""
  sign-identity:
    description: "Signing identity (alternative to certificate name)"
    required: false
    default: ""
  archive-name:   
    description: "Define name of the archive produced with action 'archive'. (Default is 4d project name with space replaced by -)"
    required: false
    default: ""
  before-build:   
    description: "Script or binary to execute before the build action starts. Can be a shell command, script path, or executable binary."
    required: false
    default: ""
  after-build:   
    description: "Script or binary to execute after the build action completes. Can be a shell command, script path, or executable binary."
    required: false
    default: ""

  product-line:
    description: 'tool4d product line'
    required: false
    default: "20.x"
  version:
    description: 'tool4d version'
    required: false
    default: "20.7"
  build:
    description: 'tool4d build number'
    required: false
    default: "latest"
  token:
    description: 'if needed a token to download'
    required: false
runs:
  using: 'composite'
  steps:
    - id: setup
      name: Setup environment and certificates
      shell: bash
      run: |
        WORKINK_DIRECTORY="${{ github.workspace }}"
        WORKINK_DIRECTORY=$(echo $WORKINK_DIRECTORY|sed -e 's/\\/\\\\/g') # escape workspace for json
        echo "WORKINK_DIRECTORY=$WORKINK_DIRECTORY" >> $GITHUB_ENV
        
        if [[ -z "${RUNNER_DEBUG}" ]]; then
           echo "RUNNER_DEBUG=0" >> $GITHUB_ENV
        else
           echo "RUNNER_DEBUG=$RUNNER_DEBUG" >> $GITHUB_ENV
        fi
        
        MY_RUNNER_TMP=$(echo "${{ runner.temp }}" | sed 's/\\/\//g')
        echo "TMP=$MY_RUNNER_TMP"
        echo "ERROR_FLAG=$MY_RUNNER_TMP/error_flag" >> $GITHUB_ENV
        
        # Certificate setup for macOS
        if [[ "$RUNNER_OS" == "macOS" ]]; then
          # Handle base64 encoded certificate
          if [[ -n "${{ inputs.sign-certificate-base64 }}" ]]; then
            CERT_PATH="$MY_RUNNER_TMP/signing_cert.p12"
            echo "${{ inputs.sign-certificate-base64 }}" | base64 -d > "$CERT_PATH"
            echo "CERT_PATH=$CERT_PATH" >> $GITHUB_ENV
            
            # Create temporary keychain
            KEYCHAIN_PATH="$MY_RUNNER_TMP/signing.keychain"
            KEYCHAIN_PASSWORD="${{ inputs.keychain-password }}"
            if [[ -z "$KEYCHAIN_PASSWORD" ]]; then
              KEYCHAIN_PASSWORD=$(openssl rand -base64 32)
            fi
            
            security create-keychain -p "$KEYCHAIN_PASSWORD" "$KEYCHAIN_PATH"
            security set-keychain-settings -lut 21600 "$KEYCHAIN_PATH"
            security unlock-keychain -p "$KEYCHAIN_PASSWORD" "$KEYCHAIN_PATH"
            
            # Import certificate
            security import "$CERT_PATH" -P "${{ inputs.sign-certificate-password }}" -A -t cert -f pkcs12 -k "$KEYCHAIN_PATH"
            security list-keychain -d user -s "$KEYCHAIN_PATH"
            
            echo "KEYCHAIN_PATH=$KEYCHAIN_PATH" >> $GITHUB_ENV
          fi
          
          # Handle certificate file path
          if [[ -n "${{ inputs.sign-certificate-path }}" ]]; then
            echo "CERT_PATH=${{ inputs.sign-certificate-path }}" >> $GITHUB_ENV
          fi
        fi
        
        # Certificate setup for Windows
        if [[ "$RUNNER_OS" == "Windows" ]]; then
          if [[ -n "${{ inputs.sign-certificate-base64 }}" ]]; then
            CERT_PATH="$MY_RUNNER_TMP/signing_cert.p12"
            echo "${{ inputs.sign-certificate-base64 }}" | base64 -d > "$CERT_PATH"
            echo "CERT_PATH=$CERT_PATH" >> $GITHUB_ENV
          fi
        fi
        
        echo "Certificate setup completed for $RUNNER_OS"
    - id: tool4d
      uses: 4d/tool4d-action@v3.1
      env:
        GITHUB_THIS_ACTION_PATH: ${{ github.action_path }}
      with:
        product-line: "${{ inputs.product-line }}"
        version: "${{ inputs.version }}"
        build: "${{ inputs.build }}"
        token: "${{ inputs.token }}"
        project: "${{env.GITHUB_THIS_ACTION_PATH}}/Project/actions.4DProject"
        user-param: '{"path": "${{ inputs.project }}", "workingDirectory": "${{ env.WORKINK_DIRECTORY }}",
          "actions":"${{ inputs.actions }}",
          "outputDirectory":"${{ inputs.output-directory }}",
          "signCertificate":"${{ inputs.sign-certificate }}",
          "signCertificatePath":"${{ env.CERT_PATH }}",
          "signCertificatePassword":"${{ inputs.sign-certificate-password }}",
          "signIdentity":"${{ inputs.sign-identity }}",
          "signFiles":"${{ inputs.sign-files }}",
          "entitlementsFile":"${{ inputs.entitlements-file }}",
          "keychainPath":"${{ env.KEYCHAIN_PATH }}",
          "archiveName":"${{ inputs.archive-name }}",
          "beforeBuild":"${{ inputs.before-build }}",
          "afterBuild":"${{ inputs.after-build }}",
          "options": "{ \"generateTypingMethods\": \"${{ inputs.generate-typing-methods }}\", \"generateSymbols\": \"${{ inputs.generate-symbols }}\", \"typeInferences\": \"${{ inputs.type-inference }}\", \"targets\": \"${{ inputs.targets }}\" }" , 
          "debug": ${{ env.RUNNER_DEBUG }}, "ignoreWarnings": "${{ inputs.ignore-warnings }}", "failOnWarning": "${{ inputs.fail-on-warning }}", "errorFlag": "${{ env.ERROR_FLAG }}" }'
        startup-method: main
        error-flag: "${{env.ERROR_FLAG}}"
        
    - id: cleanup
      name: Cleanup certificates
      if: always()
      shell: bash
      run: |
        # Cleanup macOS keychain
        if [[ "$RUNNER_OS" == "macOS" && -n "${{ env.KEYCHAIN_PATH }}" ]]; then
          echo "Cleaning up keychain: ${{ env.KEYCHAIN_PATH }}"
          security delete-keychain "${{ env.KEYCHAIN_PATH }}" || true
        fi
        
        # Cleanup certificate files
        if [[ -n "${{ env.CERT_PATH }}" ]]; then
          echo "Cleaning up certificate file: ${{ env.CERT_PATH }}"
          rm -f "${{ env.CERT_PATH }}" || true
        fi
        
        echo "Certificate cleanup completed"
